# Cloud9 
Our robot named “Cloud9” is a microbot with a code size of 645 bytes. It is built specifically for one-versus-one battles against targets with basic linear or circular movement. The movement of Cloud9 bot can be described as a pullback toy in which it swings far and rewinds step by step. With this movement, the bot will progressively move in one direction and then reset back to its original position. This movement is inspired from the multiplayer online battle arena game, League of Legends, where a character will shoot, move, and repeat to maximize damage output on one specific target while being able to move. For this strafe movement to work successfully, we programmed Cloud9 bot to turn perpendicular to the current robot scanned, so it allows our robot to revolve around our target like a clock and makes it harder for them to hit us. In the robocode community, our type of movement is categorized as “stop and go”. Stop and go movement is specifically designed to counter against linear targeting systems and other basic radar scans which do not take factor in where the targeted robot might move next. Going against linear or circular targeting systems, our movement can be easily calculated and predicted. The stop and go movement works by keeping track of the enemy robot and responds accordingly to when they fire. So, when the enemy robot fires a bullet while Cloud9 is moving, we simply stop. When Cloud9 is not moving and they fire at the bullet, we simply move. 
For the radar portion of Cloud9, the radar is characterized as a one-versus-one radar. Because it is one-versus-one, the radar is relatively simple as we will constantly keep turning the radar 360 degrees and then keep the radar constantly spinning on locations toward the scanned robot. If you were to run a visual display of the radar on Cloud9, it looks like a narrow beam that is constantly locked on to the first target it scanned. While this scan will rarely never lose track of its target, it is poor in situations against multiple robots because it will prioritize the one specific target despite there being bots near Cloud9. 
The targeting system used is rather simple as it utilizes information gained from a few radar scans. Cloud9’s targeting predicts the enemy location after one to two scans and then uses a formula to calculate the predicted movement. The weakness of this method is that it will usually only work against one type of movement that follows a relatively simple pattern. Any robot with random and unpredicted linear movement will throw off Cloud9’s targeting and make our bot severely inaccurate. In the robocode community, this type of targeting is named linear targeting, which specializes in targets moving in large arcs or half circles. To conserve energy, Cloud9 fires a set power depending on the distance of the enemy. If the enemy is less than 200 pixels away, it will fire a full power of 3. If the enemy is then 400 but more than 200 pixels, it will fire 2.7, and will fire 2 at more than 400 pixels away. As our targeting system becomes inaccurate at further distances, Cloud9 is designed to output maximum damage while being energy efficient. 
To begin, we first extended Cloud9 to the superclass AdvancedRobot rather than Robot. Then we set the condition true for setAdjustGunForRobotTurn and setAdjustGunForGunTurn. This allows the gun and radar to turn independent from one another and allow our 1v1 radar to continually lock on and linear targeting to work continuously by allowing the gun to fire ahead of the radar. In our robot main loop, we have the method turnRadarRightRadians() and we put in the parameter Double.POSITIVE_INFINITY (also known as 360 degrees) to first acquire any targets on the map. In onScannedRobot method, we have another setTurnRadarRightRadians that is placed there to continually track our target and not allow them to slip. For our special stop and go movement, the code consists of monitoring the enemy energy level and comparing it with the last scan. We used an if statement with the condition that if we are not moving (getDistanceRemaining()) and if they have fired, then we would move ahead 45 pixels, and then store their current energy level(e.getEnergy()) to compare for the next scan through a static variable prevEnergy. To turn the bot perpendicular with respect to the enemy, we get the enemy’s bearing and add 90 degrees and turn right of that angle. This makes Cloud9 always at a right angle to the enemy and allow strafing. In an attempt to conserve energy with our shots, we wrote an if-else condition that fires accordingly to the distance of the enemy. Since the further they are, we have less accuracy, so we set the firepower smaller. This portion depends on the instance method getDistance() and e is our enemy object, which we will do e.get Distance() to get that objects distance relative to our owns.
Cloud9’s linear targeting works by first obtaining the enemy’s turn rate and the current position of the enemy bot. To do so, we first get their current heading with e.getHeadingRadians() and then subtract it with its previous one which is a static variable named oldEnemyHeading from the last scan. To find the target position, we get our own coordinates first with getX() and getY() and use that to calculate the position of the target relative to our position based off the inverse of the unit-circle. We need to get the absolute bearing which is the enemy’s bearing radian (e.getBearingRadians()) plus our current heading radian (getHeadingRadians()). Then we add our x-axis (getX()) and add the distance from the enemy to us and multiply by the sin of the absolute bearing. For the y coordinate, we add our y-axis (getY()) to the distance from the enemy multiplied by the cosine of the absolute bearing. Now that we have our predicted enemy coordinates, it’s time to figure out their next projected location. We assume the target is having the same turn rate every time, and so we predict the enemy position by calculating a new velocity vector and adding it to the previous position scanned. This is displayed in our code predictedX = predictedX + Math.sin(enemyHeading) * enemyVelocity. We then use enemyHeading += enemyHeadingChange for the next initial heading for the next approximation in the next scan. However, for this last portion of the code used to calculate the next location, we put it in a while loop that determines first if the bullet travelled far enough is even able to hit our target. While the change in time beginning at 0, multiplied by the bullet velocity as shown by ((++deltaTime) * 20.0-3.0*bulletPower) is less than the distance from the enemy and us (Point2D.Double.distance(myX, myY, predicted, predicted)), then we would run the calculation. In order to use the Point2D.Double.distance we had to import java.aw.geom to have a method possible of calculating distance between two coordinates. Inside this while loop, we also have an if condition that assumes that the enemy bot will come to a stop when they approach a wall. The condition is that the x is less than 18 pixels, y is less than 18 pixels, x is more than the battle width – 18, y is more than the battle height – 18, then it will pick the predicted x and y that is not colliding to the wall. The reason why it is 18 is that the size of a robot is 36 by 36 pixels non-rotating square, so the radius is 18—hence we use 18 as the distance from the wall and the robot. Anything less than 18 and the robot would be considered sticking inside the wall. Lastly, to turn the gun we determine how much degree by performing Math.atan2(predictedX – getX(), predicted – getY()) and using Util.snormalAbsoluteAngle which normalizes an angle to an absolute angle. We take this degree and subtract from our current gun heading in radians with getGunHeadingRadians() and putting that into the method Utils.normalRelativeAngle which will convert that to a relative angle to get the final degree to turn right with. 
This robot is quite good at 1v1s against relatively simple-moving, predictable bots. Against groups it runs into some difficulties. Primarily, a common situation was where Cloud9 is locked in on a single robot while a third robot was focused on Cloud9. Even worse was when the targeted robot and the third robot were both locked in on Cloud9. There was no possible way to expect Cloud9 to defeat its first opponent, lock onto the second opponent, and beat the second opponent while being attacked. In order to get out of this pickle, Cloud9 would maneuver out of the second robots line of fire and then refocus back onto a target. This action was executed when onHitByBullet() so it was quite a frequent series of events. Some robocode fights are won by being the last robot standing which the code helps accomplish. However, most fights, and the one in class, are won by the most damage done in a series of fights. For these battles this code can be detrimental because instead of outputting damage Cloud9 is trying to reposition itself and that is a missed opportunity of firing bullets. For this reason, it was taken out before the class battles. 
Cloud9’s strafing motion has a knack for getting it stuck in a corner. To combat this when Cloud9 hit a wall it would record the X position. The second time it hit a wall it would get the X position again. If the difference between the X positions are arbitrarily close then Cloud9 will change its bearing by 30 degrees. It is likely that Cloud9 might still be stuck in the corner but with significantly more room to move because the hypotenuse (Cloud9’s strafing line) for sin(theta+30) is larger than sin(theta) where theta is set on the north and south walls. It is ok for Cloud9 to still be relatively stuck in the corner as long as it still has plenty of movement to dodge bullets. That is the main goal to survive: dodge bullets. The way the code is currently structured only allows for it to correct itself for two corners touching one of the walls, depending on which it hit first. It could correct itself if it kept getting stuck on those two corners but not the two on the opposing wall. This wasn’t corrected because it is very unlikely that Cloud9 gets stuck on one wall, frees itself, makes it away across the whole battlefield, and gets stuck in a corner again. In trial battles (when building the bot) it would experience this sequence of events maybe 1 out 50 fights. If the bot is to be further developed, this would be an obvious first step to a more robust bot. 
If you would like to test this code, you first will need Robocode. You will need to create a new robot and paste Cloud9’s code in. Now, if you have the source code, you will need to open the Robot Editor. The robot editor is accessed through the main robocode console. You will need to launch robocode and at the top, you should see the tab ‘Robot’. Click on ‘Robot’, and on the drop-down items, select ‘Source Editor’. Click on the tab ‘File’, and select ‘New’, ‘Robot’. Now follow the prompt of providing your robot name and package directory. You now must copy and paste the Cloud9 code into the robot editor. Be sure to change the class name of Cloud9 to the name of your robot you created. After you have done this, you will click on the ‘Compiler’ tab at the top, and press ‘Compile’. Once you are done compiling, it should have created a .class file in the directory you created. Now to run the robot you will go back to the main Robocode application and select the ‘Battle’ tab. Click on the drop-down item ‘New’ and a new popup will load and allow you to select robots to battle with. Select the bot you created with Cloud9’s code and one or more robots to battle with. 
